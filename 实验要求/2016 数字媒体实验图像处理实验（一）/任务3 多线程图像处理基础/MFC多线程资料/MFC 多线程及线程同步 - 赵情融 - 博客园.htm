<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
<title>MFC 多线程及线程同步 - 赵情融 - 博客园</title>
<link type="text/css" rel="stylesheet" href="http://common.cnblogs.com/blog/css/common.css?id=20120912"/>
<link id="MainCss" type="text/css" rel="stylesheet" href="http://common.cnblogs.com/Skins/Valentine/style.css?id=20120912"/>
<link type="text/css" rel="stylesheet" href="http://common.cnblogs.com/blog/css/common2.css"/>
<link type="text/css" rel="stylesheet" href="http://common.cnblogs.com/css/shStyle.css"/>
<link title="RSS" type="application/rss+xml" rel="alternate" href="http://www.cnblogs.com/zqrferrari/rss"/>
<link title="RSD" type="application/rsd+xml" rel="EditURI" href="http://www.cnblogs.com/zqrferrari/rsd.xml"/>
<link type="application/wlwmanifest+xml" rel="wlwmanifest" href="http://www.cnblogs.com/zqrferrari/wlwmanifest.xml"/>
<script src="http://common.cnblogs.com/script/jquery.js" type="text/javascript"></script>  
<script type="text/javascript">
var currentBlogApp = 'zqrferrari';
</script>
<script src="http://common.cnblogs.com/blog/script/common.js?id=20120912" type="text/javascript"></script> 
<script src="http://common.cnblogs.com/script/json2.js" type="text/javascript"></script>
<script type="text/javascript" src="http://common.cnblogs.com/script/syntaxHighlighter.js"></script>
</head>
<body>
<a name="top"></a>

<!--done-->
<TABLE cellpadding="0" cellspacing="0" border="0" align="center" width="100%">
<TR>
	<TD width=184 background="/skins/Valentine/images/banner1.gif"></TD>
	<TD background="/skins/Valentine/images/banner.gif">
<!--done-->
<div class="header">
	<div class="headerText">
		<a id="Header1_HeaderTitle" class="headermaintitle" href="http://www.cnblogs.com/zqrferrari/">ZqrFerrari</a><br>
		<span style="font-size:12px;color:#4371A6;padding-left:20;">努力学习，开心生活</span>
	</div>
</div>
</TD>
	<TD width=295 background="/skins/Valentine/images/banner2.gif"></TD>
</TR>
</TABLE>
<div id="mylinks">
<!--done-->
<a id="MyLinks1_HomeLink" class="menu" href="http://www.cnblogs.com/">博客园</a>&nbsp;&nbsp;&nbsp;<a id="MyLinks1_MyHomeLink" class="mainmenu" href="http://www.cnblogs.com/zqrferrari/">首页</a>&nbsp;&nbsp;&nbsp;<a id="MyLinks1_NewPostLink" class="mainmenu" rel="nofollow" href="http://www.cnblogs.com/zqrferrari/admin/EditPosts.aspx?opt=1">新随笔</a>&nbsp;&nbsp;&nbsp;<a id="MyLinks1_NewArticleLink" class="mainmenu" href="/EnterMyBlog.aspx?NewArticle=1">新文章</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a id="MyLinks1_Admin" class="menu" rel="nofollow" href="http://www.cnblogs.com/zqrferrari/admin/EditPosts.aspx">管理</a>
</div>
<div id="mytopmenu">
	
		<DIV id="mystats">
			</DIV>
	
</div>
<div id="leftcontent">
	
		<DIV id="leftcontentcontainer">
			<div id="blog-calendar-block" style="display:none"><div id="blog-calendar"></div>
</div><br>
			
			<div id="blog-sidecolumn"></div></DIV>
	
</div>
<div id="centercontent">
	
	
<!--done-->
<div class = "post">
	<div class = "postTitle">
		<a id="cb_post_title_url" class="postTitle2" href="http://www.cnblogs.com/zqrferrari/archive/2010/07/07/1773113.html">MFC 多线程及线程同步</a>
	</div>
	<div id="cnblogs_post_body"><p><strong style="font-size: 10pt">一、MFC对多线程编程的支持</strong></p>
<p><span style="font-size: 10pt">　　MFC中有两类线程，分别称之为工作者线程和用户界面线程。二者的主要区别在于工作者线程没有消息循环，而用户界面线程有自己的消息队列和消息循环。</span><br /><span style="font-size: 10pt">　　工作者线程没有消息机制，通常用来执行后台计算和维护任务，如冗长的计算过程，打印机的后台打印等。用户界面线程一般用于处理独立于其他线程执行之外的用户输入，响应用户及系统所产生的事件和消息等。但对于Win32的API编程而言，这两种线程是没有区别的，它们都只需线程的启动地址即可启动线程来执行任务。</span><br /><span style="font-size: 10pt">　　在MFC中，一般用全局函数AfxBeginThread()来创建并初始化一个线程的运行，该函数有两种重载形式，分别用于创建工作者线程和用户界面线程。两种重载函数原型和参数分别说明如下：</span></p>
<p><span style="font-size: 10pt">　　(1) </span><font size="2" face="Tahoma"><span style="font-size: 10pt">CWinThread* AfxBeginThread( </span></font></p>
<p><font size="2" face="Tahoma"><span style="font-size: 10pt">　　　　　　&nbsp; AFX_THREADPROC pfnThreadProc,</span><br /><span style="font-size: 10pt">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;　　　　 LPVOID pParam,</span><br /><span style="font-size: 10pt">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;　　 　　int nPriority = THREAD_PRIORITY_NORMAL,</span><br /><span style="font-size: 10pt">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;　　　　 UNT nStackSize = 0,</span><br /><span style="font-size: 10pt">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;　　　　 DWORD dwCreateFlags = 0,</span><br /><span style="font-size: 10pt">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;　　　　 LPSECURITY_ATTRIBUTES lpSecurityAttrs = NULL</span><br /><span style="font-size: 10pt">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;　　　　 );//用于创建工作者线程</span></font></p>
<p><span style="font-size: 10pt">　　PfnThreadProc:指向工作者线程的执行函数的指针，线程函数原型必须声明如下： </span></p>
<p><span style="font-size: 10pt">　　UINT ExecutingFunction(LPVOID pParam);</span></p>
<p><span style="font-size: 10pt">　　请注意，ExecutingFunction()应返回一个UINT类型的值，用以指明该函数结束的原因。一般情况下，返回0表明执行成功。 </span></p>
<ul><li><span style="font-size: 10pt">pParam：　　&nbsp;&nbsp;&nbsp; 一个32位参数，执行函数将用某种方式解释该值。它可以是数值，或是指向一个结构的指针，甚至可以被忽略；</span></li><li><span style="font-size: 10pt">nPriority：　　&nbsp;&nbsp; 线程的优先级。如果为0，则线程与其父线程具有相同的优先级；</span></li><li><span style="font-size: 10pt">nStackSize:　　 线程为自己分配堆栈的大小，其单位为字节。如果nStackSize被设为0，则线程的堆栈被设置成与父线程堆栈相同大小；</span></li><li><span style="font-size: 10pt">dwCreateFlags：如果为0，则线程在创建后立刻开始执行。如果为CREATE_SUSPEND，则线程在创建后立刻被挂起；</span></li><li><span style="font-size: 10pt">lpSecurityAttrs：线程的安全属性指针，一般为NULL； </span></li></ul>
<p><span style="font-size: 10pt">　　(2) </span><font size="2" face="Tahoma"><span style="font-size: 10pt">CWinThread* AfxBeginThread( </span></font></p>
<p><font size="2" face="Tahoma"><span style="font-size: 10pt">　　　　　　&nbsp;CRuntimeClass* pThreadClass,</span><br /><span style="font-size: 10pt">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;　　 　　int nPriority = THREAD_PRIORITY_NORMAL,</span><br /><span style="font-size: 10pt">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;　　　　 UNT nStackSize = 0,</span><br /><span style="font-size: 10pt">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;　　　　 DWORD dwCreateFlags = 0,</span><br /><span style="font-size: 10pt">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;　　　　 LPSECURITY_ATTRIBUTES lpSecurityAttrs = NULL</span><br /><span style="font-size: 10pt">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;　　　　 );</span></font><span style="font-size: 10pt">　</span></p>
<p><span style="font-size: 10pt">　　pThreadClass 是指向 CWinThread 的一个导出类的运行时类对象的指针，该导出类定义了被创建的用户界面线程的启动、退出等；其它参数的意义同形式1。使用函数的这个原型生成的线程也有消息机制，在以后的例子中我们将发现同主线程的机制几乎一样。</span></p>
<p><span style="font-size: 10pt">　　下面我们对CWinThread类的数据成员及常用函数进行简要说明。</span></p>
<ul><li><span style="font-size: 10pt">m_hThread：&nbsp;&nbsp;&nbsp; 　当前线程的句柄；</span></li><li><span style="font-size: 10pt">m_nThreadID:&nbsp; 　当前线程的ID；</span></li><li><span style="font-size: 10pt">m_pMainWnd：　指向应用程序主窗口的指针 </span></li></ul><pre><span style="font-size: 10pt">　　BOOL CWinThread::CreateThread(DWORD dwCreateFlags=0,UINT nStackSize=0,LPSECURITY_ATTRIBUTES lpSecurityAttrs=NULL);</span></pre>
<p><span style="font-size: 10pt">　　该函数中的dwCreateFlags、nStackSize、lpSecurityAttrs参数和API函数CreateThread中的对应参数有相同含义，该函数执行成功，返回非0值，否则返回0。</span><br /><span style="font-size: 10pt">　　一般情况下，调用AfxBeginThread()来一次性地创建并启动一个线程，但是也可以通过两步法来创建线程：首先创建CWinThread类的一个对象，然后调用该对象的成员函数CreateThread()来启动该线程。</span></p><pre><span style="font-size: 10pt">　　virtual BOOL CWinThread::InitInstance();</span></pre>
<p><span style="font-size: 10pt">　　重载该函数以控制用户界面线程实例的初始化。初始化成功则返回非0值，否则返回0。用户界面线程经常重载该函数，工作者线程一般不使用InitInstance()。 </span></p><pre><span style="font-size: 10pt">　　virtual int CWinThread::ExitInstance();</span></pre>
<p><span style="font-size: 10pt">　　在线程终结前重载该函数进行一些必要的清理工作。该函数返回线程的退出码，0表示执行成功，非0值用来标识各种错误。同InitInstance()成员函数一样，该函数也只适用于用户界面线程。</span></p>
<p>&nbsp;</p>
<p><strong style="font-size: 10pt">二、MFC中线程同步</strong></p>
<p><strong></strong><span style="font-size: 10pt">&nbsp;　　</span><font color="#232323" size="2"><span style="font-size: 10pt">在程序中使用多线程时，一般很少有多个线程能在其生命期内进行完全独立的操作。更多的情况是一些线程进行某些处理操作，而其他的线程必须对其处理结果进行了解。正常情况下对这种处理结果的了解应当在其处理任务完成后进行。</span><br /><span style="font-size: 10pt">　　如果不采取适当的措施，其他线程往往会在线程处理任务结束前就去访问处理结果，这就很有可能得到有关处理结果的错误了解。例如，多个线程同时访问同一个全局变量，如果都是读取操作，则不会出现问题。如果一个线程负责改变此变量的值，而其他线程负责同时读取变量内容，则不能保证读取到的数据是经过写线程修改后的。</span><br /><span style="font-size: 10pt">　　为了确保读线程读取到的是经过修改的变量，就必须在向变量写入数据时禁止其他线程对其的任何访问，直至赋值过程结束后再解除对其他线程的访问限制。象这种保证线程能了解其他线程任务处理结束后的处理结果而采取的保护措施即为线程同步。</span><br /><span style="font-size: 10pt">　　线程的同步可分用户模式的线程同步和内核对象的线程同步两大类。用户模式中线程的同步方法主要有原子访问和临界区等方法。其特点是同步速度特别快，适合于对线程运行速度有严格要求的场合。</span><br /><span style="font-size: 10pt">　　内核对象的线程同步则主要由事件、等待定时器、信号量以及信号灯等内核对象构成。由于这种同步机制使用了内核对象，使用时必须将线程从用户模式切换到内核模式，而这种转换一般要耗费近千个CPU周期，因此同步速度较慢，但在适用性上却要远优于用户模式的线程同步方式。</span></font></p>
<p><font color="#232323" size="2"><span style="font-size: 10pt"><strong>　　</strong></span></font></p>
<p><font color="#232323" size="2"><span style="font-size: 12pt"><strong style="font-size: 10pt">　　1.临界区<br /></strong>　</span><span style="font-size: 10pt">　临界区（Critical Section）是一段独占对某些共享资源访问的代码，在任意时刻只允许一个线程对共享资源进行访问。如果有多个线程试图同时访问临界区，那么在有一个线程进入后其他所有试图访问此临界区的线程将被挂起，并一直持续到进入临界区的线程离开。临界区在被释放后，其他线程可以继续抢占，并以此达到用原子方式操作共享资源的目的。<br /></span><span style="font-size: 10pt">　　临界区在使用时以CRITICAL_SECTION结构对象保护共享资源，并分别用EnterCriticalSection（）和LeaveCriticalSection（）函数去标识和释放一个临界区。所用到的CRITICAL_SECTION结构对象必须经过InitializeCriticalSection（）的初始化后才能使用，而且必须确保所有线程中的任何试图访问此共享资源的代码都处在此临界区的保护之下。否则临界区将不会起到应有的作用，共享资源依然有被破坏的可能。</span><font color="#232323" size="2"><span style="font-size: 12pt"><br /></p>
<p>
<div class="cnblogs_code" onclick="cnblogs_code_show('20ef27a6-4008-4806-9412-4b83d355b916')"><img id="code_img_closed_20ef27a6-4008-4806-9412-4b83d355b916" class="code_img_closed" alt="" src="http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif" /><img style="display: none" id="code_img_opened_20ef27a6-4008-4806-9412-4b83d355b916" class="code_img_opened" onclick="cnblogs_code_hide('20ef27a6-4008-4806-9412-4b83d355b916',event)" src="http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif"><span class="cnblogs_code_collapse">代码</span> 
<div id="cnblogs_code_open_20ef27a6-4008-4806-9412-4b83d355b916" class="cnblogs_code_hide">
<div><!--<br/ /><br/ />Code highlighting produced by Actipro CodeHighlighter (freeware)<br/ />http://www.CodeHighlighter.com/<br/ /><br/ />--><span style="color: #000000">CRITICAL_SECTION&nbsp;g_cs;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span style="color: #008000">//</span><span style="color: #008000">&nbsp;临界区结构对象</span><span style="color: #008000"><br /></span><span style="color: #0000ff">char</span><span style="color: #000000">&nbsp;g_cArray[</span><span style="color: #800080">10</span><span style="color: #000000">];&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span style="color: #008000">//</span><span style="color: #008000">&nbsp;共享资源&nbsp;</span><span style="color: #008000"><br /></span><span style="color: #000000"><br /><br />UINT&nbsp;ThreadProc10(LPVOID&nbsp;pParam)<br />{<br />　EnterCriticalSection(</span><span style="color: #000000">&amp;</span><span style="color: #000000">g_cs);&nbsp;&nbsp;&nbsp;&nbsp;　</span><span style="color: #008000">//</span><span style="color: #008000">&nbsp;进入临界区</span><span style="color: #008000"><br /></span><span style="color: #000000">　</span><span style="color: #0000ff">for</span><span style="color: #000000">&nbsp;(</span><span style="color: #0000ff">int</span><span style="color: #000000">&nbsp;i&nbsp;</span><span style="color: #000000">=</span><span style="color: #000000">&nbsp;</span><span style="color: #800080">0</span><span style="color: #000000">;&nbsp;i&nbsp;</span><span style="color: #000000">&lt;</span><span style="color: #000000">&nbsp;</span><span style="color: #800080">10</span><span style="color: #000000">;&nbsp;i</span><span style="color: #000000">++</span><span style="color: #000000">)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span style="color: #008000">//</span><span style="color: #008000">&nbsp;对共享资源进行写入操作</span><span style="color: #008000"><br /></span><span style="color: #000000">　{<br />　　g_cArray[i]&nbsp;</span><span style="color: #000000">=</span><span style="color: #000000">&nbsp;</span><span style="color: #800000">'</span><span style="color: #800000">a</span><span style="color: #800000">'</span><span style="color: #000000">;<br />　　Sleep(</span><span style="color: #800080">1</span><span style="color: #000000">);<br />　}<br /><br />　LeaveCriticalSection(</span><span style="color: #000000">&amp;</span><span style="color: #000000">g_cs);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;　</span><span style="color: #008000">//</span><span style="color: #008000">&nbsp;离开临界区</span><span style="color: #008000"><br /></span><span style="color: #000000">　</span><span style="color: #0000ff">return</span><span style="color: #000000">&nbsp;</span><span style="color: #800080">0</span><span style="color: #000000">;<br />}<br />UINT&nbsp;ThreadProc11(LPVOID&nbsp;pParam)<br />{<br />　<br />　EnterCriticalSection(</span><span style="color: #000000">&amp;</span><span style="color: #000000">g_cs);<br /><br />　</span><span style="color: #0000ff">for</span><span style="color: #000000">&nbsp;(</span><span style="color: #0000ff">int</span><span style="color: #000000">&nbsp;i&nbsp;</span><span style="color: #000000">=</span><span style="color: #000000">&nbsp;</span><span style="color: #800080">0</span><span style="color: #000000">;&nbsp;i&nbsp;</span><span style="color: #000000">&lt;</span><span style="color: #000000">&nbsp;</span><span style="color: #800080">10</span><span style="color: #000000">;&nbsp;i</span><span style="color: #000000">++</span><span style="color: #000000">)<br />　{<br />　　g_cArray[</span><span style="color: #800080">10</span><span style="color: #000000">&nbsp;</span><span style="color: #000000">-</span><span style="color: #000000">&nbsp;i&nbsp;</span><span style="color: #000000">-</span><span style="color: #000000">&nbsp;</span><span style="color: #800080">1</span><span style="color: #000000">]&nbsp;</span><span style="color: #000000">=</span><span style="color: #000000">&nbsp;</span><span style="color: #800000">'</span><span style="color: #800000">b</span><span style="color: #800000">'</span><span style="color: #000000">;<br />　　Sleep(</span><span style="color: #800080">1</span><span style="color: #000000">);<br />　}<br /><br />　LeaveCriticalSection(</span><span style="color: #000000">&amp;</span><span style="color: #000000">g_cs);<br />　</span><span style="color: #0000ff">return</span><span style="color: #000000">&nbsp;</span><span style="color: #800080">0</span><span style="color: #000000">;<br />}<br />&#8230;&#8230;<br /></span><span style="color: #0000ff">void</span><span style="color: #000000">&nbsp;CSample08View::OnCriticalSection()&nbsp;<br />{<br />　InitializeCriticalSection(</span><span style="color: #000000">&amp;</span><span style="color: #000000">g_cs);　&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span style="color: #008000">//</span><span style="color: #008000">&nbsp;初始化临界区</span><span style="color: #008000"><br /></span><span style="color: #000000">　<br />　AfxBeginThread(ThreadProc10,&nbsp;NULL);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span style="color: #008000">//</span><span style="color: #008000">&nbsp;启动线程</span><span style="color: #008000"><br /></span><span style="color: #000000">　AfxBeginThread(ThreadProc11,&nbsp;NULL);<br /><br />　Sleep(</span><span style="color: #800080">300</span><span style="color: #000000">);<br /><br />　CString&nbsp;sResult&nbsp;</span><span style="color: #000000">=</span><span style="color: #000000">&nbsp;CString(g_cArray);<br />　AfxMessageBox(sResult);<br />}</span></div></div></div></span></font><font size="2">　　在使用临界区时，一般不允许其运行时间过长，只要进入临界区的线程还没有离开，其他所有试图进入此临界区的线程都会被挂起而进入到等待状态，并会在一定程度上影响。程序的运行性能。尤其需要注意的是不要将等待用户输入或是其他一些外界干预的操作包含到临界区。如果进入了临界区却一直没有释放，同样也会引起其他线程的长时间等待。换句话说，在执行了EnterCriticalSection（）语句进入临界区后无论发生什么，必须确保与之匹配的LeaveCriticalSection（）都能够被执行到。可以通过添加结构化异常处理代码来确保LeaveCriticalSection（）语句的执行。虽然临界区同步速度很快，但却只能用来同步本进程内的线程，而不可用来同步多个进程中的线程。<br />　　MFC为临界区提供有一个CCriticalSection类，使用该类进行线程同步处理是非常简单的，只需在线程函数中用CCriticalSection类成员函数Lock（）和UnLock（）标定出被保护代码片段即可。对于上述代码，可通过CCriticalSection类将其改写如下：</font></font> 
<p><font color="#232323" size="2"><span style="font-size: 12pt"></p>
<div class="cnblogs_code" onclick="cnblogs_code_show('ab7cd27d-2930-4c3c-a7d4-f34ab35d84c4')"><img id="code_img_closed_ab7cd27d-2930-4c3c-a7d4-f34ab35d84c4" class="code_img_closed" alt="" src="http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif" /><img style="display: none" id="code_img_opened_ab7cd27d-2930-4c3c-a7d4-f34ab35d84c4" class="code_img_opened" onclick="cnblogs_code_hide('ab7cd27d-2930-4c3c-a7d4-f34ab35d84c4',event)" src="http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif"><span class="cnblogs_code_collapse">代码</span> 
<div id="cnblogs_code_open_ab7cd27d-2930-4c3c-a7d4-f34ab35d84c4" class="cnblogs_code_hide">
<div><!--<br/ /><br/ />Code highlighting produced by Actipro CodeHighlighter (freeware)<br/ />http://www.CodeHighlighter.com/<br/ /><br/ />--><span style="color: #000000">CCriticalSection&nbsp;g_clsCriticalSection;　　</span><span style="color: #008000">//</span><span style="color: #008000">&nbsp;MFC临界区类对象</span><span style="color: #008000"><br /></span><span style="color: #0000ff">char</span><span style="color: #000000">&nbsp;g_cArray[</span><span style="color: #800080">10</span><span style="color: #000000">];　　　　　　　　　　　　　 </span><span style="color: #008000">//</span><span style="color: #008000">&nbsp;共享资源&nbsp;</span><span style="color: #008000"><br /></span><span style="color: #000000"><br />UINT&nbsp;ThreadProc20(LPVOID&nbsp;pParam)<br />{<br />　g_clsCriticalSection.Lock();　　　　　&nbsp;&nbsp; </span><span style="color: #008000">//</span><span style="color: #008000">&nbsp;进入临界区</span><span style="color: #008000"><br /></span><span style="color: #000000"><br />　</span><span style="color: #0000ff">for</span><span style="color: #000000">&nbsp;(</span><span style="color: #0000ff">int</span><span style="color: #000000">&nbsp;i&nbsp;</span><span style="color: #000000">=</span><span style="color: #000000">&nbsp;</span><span style="color: #800080">0</span><span style="color: #000000">;&nbsp;i&nbsp;</span><span style="color: #000000">&lt;</span><span style="color: #000000">&nbsp;</span><span style="color: #800080">10</span><span style="color: #000000">;&nbsp;i</span><span style="color: #000000">++</span><span style="color: #000000">)&nbsp;　　　　　　</span><span style="color: #008000">//</span><span style="color: #008000">&nbsp;对共享资源进行写入操作</span><span style="color: #008000"><br /></span><span style="color: #000000">　{<br />　　g_cArray[i]&nbsp;</span><span style="color: #000000">=</span><span style="color: #000000">&nbsp;</span><span style="color: #800000">'</span><span style="color: #800000">a</span><span style="color: #800000">'</span><span style="color: #000000">;<br />　　Sleep(</span><span style="color: #800080">1</span><span style="color: #000000">);<br />　}<br />　g_clsCriticalSection.Unlock();　　　　　　</span><span style="color: #008000">//</span><span style="color: #008000">&nbsp;离开临界区</span><span style="color: #008000"><br /></span><span style="color: #000000">　</span><span style="color: #0000ff">return</span><span style="color: #000000">&nbsp;</span><span style="color: #800080">0</span><span style="color: #000000">;<br />}<br />UINT&nbsp;ThreadProc21(LPVOID&nbsp;pParam)<br />{<br />　g_clsCriticalSection.Lock();<br /><br />　</span><span style="color: #0000ff">for</span><span style="color: #000000">&nbsp;(</span><span style="color: #0000ff">int</span><span style="color: #000000">&nbsp;i&nbsp;</span><span style="color: #000000">=</span><span style="color: #000000">&nbsp;</span><span style="color: #800080">0</span><span style="color: #000000">;&nbsp;i&nbsp;</span><span style="color: #000000">&lt;</span><span style="color: #000000">&nbsp;</span><span style="color: #800080">10</span><span style="color: #000000">;&nbsp;i</span><span style="color: #000000">++</span><span style="color: #000000">)<br />　{<br />　　g_cArray[</span><span style="color: #800080">10</span><span style="color: #000000">&nbsp;</span><span style="color: #000000">-</span><span style="color: #000000">&nbsp;i&nbsp;</span><span style="color: #000000">-</span><span style="color: #000000">&nbsp;</span><span style="color: #800080">1</span><span style="color: #000000">]&nbsp;</span><span style="color: #000000">=</span><span style="color: #000000">&nbsp;</span><span style="color: #800000">'</span><span style="color: #800000">b</span><span style="color: #800000">'</span><span style="color: #000000">;<br />　　Sleep(</span><span style="color: #800080">1</span><span style="color: #000000">);<br />　}<br /><br />　g_clsCriticalSection.Unlock();<br />　</span><span style="color: #0000ff">return</span><span style="color: #000000">&nbsp;</span><span style="color: #800080">0</span><span style="color: #000000">;<br />}<br />&#8230;&#8230;<br /></span><span style="color: #0000ff">void</span><span style="color: #000000">&nbsp;CSample08View::OnCriticalSectionMfc()&nbsp;<br />{<br />　AfxBeginThread(ThreadProc20,&nbsp;NULL);<br />　AfxBeginThread(ThreadProc21,&nbsp;NULL);<br /><br />　Sleep(</span><span style="color: #800080">300</span><span style="color: #000000">);<br /><br />　CString&nbsp;sResult&nbsp;</span><span style="color: #000000">=</span><span style="color: #000000">&nbsp;CString(g_cArray);<br />　AfxMessageBox(sResult);<br />}</span></div></div></div>
<p>&nbsp;</p>
<p><strong><font color="#232323" size="2">　　2.事件内核对象</font></strong></p>
<p><font color="#232323" size="2">　　在前面讲述线程通信时曾使用过事件内核对象来进行线程间的通信，除此之外，事件内核对象也可以通过通知操作的方式来保持线程的同步。对于前面那段使用临界区保持线程同步的代码可用事件对象的线程同步方法改写如下：</font><br /></p>
<div class="cnblogs_code" onclick="cnblogs_code_show('ce76f021-7ef1-4f6a-8271-743c03fbc986')"><img id="code_img_closed_ce76f021-7ef1-4f6a-8271-743c03fbc986" class="code_img_closed" alt="" src="http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif" /><img style="display: none" id="code_img_opened_ce76f021-7ef1-4f6a-8271-743c03fbc986" class="code_img_opened" onclick="cnblogs_code_hide('ce76f021-7ef1-4f6a-8271-743c03fbc986',event)" src="http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif"><span class="cnblogs_code_collapse">代码</span> 
<div id="cnblogs_code_open_ce76f021-7ef1-4f6a-8271-743c03fbc986" class="cnblogs_code_hide">
<div><!--<br/ /><br/ />Code highlighting produced by Actipro CodeHighlighter (freeware)<br/ />http://www.CodeHighlighter.com/<br/ /><br/ />--><span style="color: #000000">HANDLE&nbsp;hEvent&nbsp;</span><span style="color: #000000">=</span><span style="color: #000000">&nbsp;NULL;&nbsp;&nbsp;　　　　　　　　　　　　</span><span style="color: #008000">//</span><span style="color: #008000">&nbsp;事件句柄</span><span style="color: #008000"><br /></span><span style="color: #000000"><br /></span><span style="color: #0000ff">char</span><span style="color: #000000">&nbsp;g_cArray[</span><span style="color: #800080">10</span><span style="color: #000000">];&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;　　　　　　　　　　　　</span><span style="color: #008000">//</span><span style="color: #008000">&nbsp;共享资源&nbsp;</span><span style="color: #008000"><br /></span><span style="color: #000000"><br />UINT&nbsp;ThreadProc12(LPVOID&nbsp;pParam)<br />{<br />　WaitForSingleObject(hEvent,&nbsp;INFINITE);　　</span><span style="color: #008000">//</span><span style="color: #008000">&nbsp;等待事件置位</span><span style="color: #008000"><br /></span><span style="color: #000000"><br />　</span><span style="color: #0000ff">for</span><span style="color: #000000">&nbsp;(</span><span style="color: #0000ff">int</span><span style="color: #000000">&nbsp;i&nbsp;</span><span style="color: #000000">=</span><span style="color: #000000">&nbsp;</span><span style="color: #800080">0</span><span style="color: #000000">;&nbsp;i&nbsp;</span><span style="color: #000000">&lt;</span><span style="color: #000000">&nbsp;</span><span style="color: #800080">10</span><span style="color: #000000">;&nbsp;i</span><span style="color: #000000">++</span><span style="color: #000000">)<br />　{<br />　　g_cArray[i]&nbsp;</span><span style="color: #000000">=</span><span style="color: #000000">&nbsp;</span><span style="color: #800000">'</span><span style="color: #800000">a</span><span style="color: #800000">'</span><span style="color: #000000">;<br />　　Sleep(</span><span style="color: #800080">1</span><span style="color: #000000">);<br />　}<br />　<br />　SetEvent(hEvent);　　　　　　　　　　　　　　</span><span style="color: #008000">//</span><span style="color: #008000">&nbsp;处理完成后即将事件对象置位</span><span style="color: #008000"><br /></span><span style="color: #000000">　</span><span style="color: #0000ff">return</span><span style="color: #000000">&nbsp;</span><span style="color: #800080">0</span><span style="color: #000000">;<br />}<br />UINT&nbsp;ThreadProc13(LPVOID&nbsp;pParam)<br />{<br />　WaitForSingleObject(hEvent,&nbsp;INFINITE);<br /><br />　</span><span style="color: #0000ff">for</span><span style="color: #000000">&nbsp;(</span><span style="color: #0000ff">int</span><span style="color: #000000">&nbsp;i&nbsp;</span><span style="color: #000000">=</span><span style="color: #000000">&nbsp;</span><span style="color: #800080">0</span><span style="color: #000000">;&nbsp;i&nbsp;</span><span style="color: #000000">&lt;</span><span style="color: #000000">&nbsp;</span><span style="color: #800080">10</span><span style="color: #000000">;&nbsp;i</span><span style="color: #000000">++</span><span style="color: #000000">)<br />　{<br />　　g_cArray[</span><span style="color: #800080">10</span><span style="color: #000000">&nbsp;</span><span style="color: #000000">-</span><span style="color: #000000">&nbsp;i&nbsp;</span><span style="color: #000000">-</span><span style="color: #000000">&nbsp;</span><span style="color: #800080">1</span><span style="color: #000000">]&nbsp;</span><span style="color: #000000">=</span><span style="color: #000000">&nbsp;</span><span style="color: #800000">'</span><span style="color: #800000">b</span><span style="color: #800000">'</span><span style="color: #000000">;<br />　　Sleep(</span><span style="color: #800080">1</span><span style="color: #000000">);<br />　}<br /><br />　SetEvent(hEvent);<br />　</span><span style="color: #0000ff">return</span><span style="color: #000000">&nbsp;</span><span style="color: #800080">0</span><span style="color: #000000">;<br />}<br />&#8230;&#8230;<br /></span><span style="color: #0000ff">void</span><span style="color: #000000">&nbsp;CSample08View::OnEvent()&nbsp;<br />{<br />　hEvent&nbsp;</span><span style="color: #000000">=</span><span style="color: #000000">&nbsp;CreateEvent(NULL,&nbsp;FALSE,&nbsp;FALSE,&nbsp;NULL);　　　　　</span><span style="color: #008000">//</span><span style="color: #008000">&nbsp;创建事件</span><span style="color: #008000"><br /></span><span style="color: #000000"><br />　SetEvent(hEvent);　　　　　　　　　　　　　　　　　　　　　&nbsp;&nbsp;</span><span style="color: #008000">//</span><span style="color: #008000">&nbsp;事件置位</span><span style="color: #008000"><br /></span><span style="color: #000000"><br />　AfxBeginThread(ThreadProc12,&nbsp;NULL);　　　　　　　　　　　　</span><span style="color: #008000">//</span><span style="color: #008000">&nbsp;启动线程</span><span style="color: #008000"><br /></span><span style="color: #000000">　AfxBeginThread(ThreadProc13,&nbsp;NULL);<br /><br />　Sleep(</span><span style="color: #800080">300</span><span style="color: #000000">);<br /><br />　CString&nbsp;sResult&nbsp;</span><span style="color: #000000">=</span><span style="color: #000000">&nbsp;CString(g_cArray);<br />　AfxMessageBox(sResult);<br />}&nbsp;<br /></span></div></div></div>
<p><font color="#232323" size="2">　　在创建线程前，首先创建一个可以自动复位的事件内核对象hEvent，而线程函数则通过WaitForSingleObject（）等待函数无限等待hEvent的置位，只有在事件置位时WaitForSingleObject（）才会返回，被保护的代码将得以执行。对于以自动复位方式创建的事件对象，在其置位后一被WaitForSingleObject（）等待到就会立即复位，也就是说在执行ThreadProc12（）中的受保护代码时，事件对象已经是复位状态的，这时即使有ThreadProc13（）对CPU的抢占，也会由于WaitForSingleObject（）没有hEvent的置位而不能继续执行，也就没有可能破坏受保护的共享资源。在ThreadProc12（）中的处理完成后可以通过SetEvent（）对hEvent的置位而允许ThreadProc13（）对共享资源g_cArray的处理。这里SetEvent（）所起的作用可以看作是对某项特定任务完成的通知。<br />　　使用临界区只能同步同一进程中的线程，而使用事件内核对象则可以对进程外的线程进行同步，其前提是得到对此事件对象的访问权。可以通过OpenEvent（）函数获取得到，其函数原型为：</font><br /></p>
<div class="cnblogs_code">
<div><!--<br/ /><br/ />Code highlighting produced by Actipro CodeHighlighter (freeware)<br/ />http://www.CodeHighlighter.com/<br/ /><br/ />--><span style="color: #000000">HANDLE&nbsp;OpenEvent(<br />　DWORD&nbsp;dwDesiredAccess,&nbsp;&nbsp;</span><span style="color: #008000">//</span><span style="color: #008000">&nbsp;访问标志</span><span style="color: #008000"><br /></span><span style="color: #000000">　BOOL&nbsp;bInheritHandle,&nbsp;&nbsp;&nbsp;&nbsp;</span><span style="color: #008000">//</span><span style="color: #008000">&nbsp;继承标志</span><span style="color: #008000"><br /></span><span style="color: #000000">　LPCTSTR&nbsp;lpName&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span style="color: #008000">//</span><span style="color: #008000">&nbsp;指向事件对象名的指针</span><span style="color: #008000"><br /></span><span style="color: #000000">);&nbsp;<br /></span></div></div><font color="#232323" size="2">　　如果事件对象已创建（在创建事件时需要指定事件名），函数将返回指定事件的句柄。对于那些在创建事件时没有指定事件名的事件内核对象，可以通过使用内核对象的继承性或是调用DuplicateHandle（）函数来调用CreateEvent（）以获得对指定事件对象的访问权。在获取到访问权后所进行的同步操作与在同一个进程中所进行的线程同步操作是一样的。<br />　　如果需要在一个线程中等待多个事件，则用WaitForMultipleObjects（）来等待。WaitForMultipleObjects（）与WaitForSingleObject（）类似，同时监视位于句柄数组中的所有句柄。这些被监视对象的句柄享有平等的优先权，任何一个句柄都不可能比其他句柄具有更高的优先权。WaitForMultipleObjects（）的函数原型为：</font><br />
<div class="cnblogs_code">
<div><!--<br/ /><br/ />Code highlighting produced by Actipro CodeHighlighter (freeware)<br/ />http://www.CodeHighlighter.com/<br/ /><br/ />--><span style="color: #000000">DWORD&nbsp;WaitForMultipleObjects(<br />　DWORD&nbsp;nCount,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span style="color: #008000">//</span><span style="color: #008000">&nbsp;等待句柄数</span><span style="color: #008000"><br /></span><span style="color: #000000">　CONST&nbsp;HANDLE&nbsp;</span><span style="color: #000000">*</span><span style="color: #000000">lpHandles,&nbsp;&nbsp;&nbsp;</span><span style="color: #008000">//</span><span style="color: #008000">&nbsp;句柄数组首地址</span><span style="color: #008000"><br /></span><span style="color: #000000">　BOOL&nbsp;fWaitAll,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span style="color: #008000">//</span><span style="color: #008000">&nbsp;等待标志</span><span style="color: #008000"><br /></span><span style="color: #000000">　DWORD&nbsp;dwMilliseconds&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span style="color: #008000">//</span><span style="color: #008000">&nbsp;等待时间间隔</span><span style="color: #008000"><br /></span><span style="color: #000000">);</span></div></div>
<p><font color="#232323" size="2">　　参数nCount指定了要等待的内核对象的数目，存放这些内核对象的数组由lpHandles来指向。fWaitAll对指定的这nCount个内核对象的两种等待方式进行了指定，为TRUE时当所有对象都被通知时函数才会返回，为FALSE则只要其中任何一个得到通知就可以返回。dwMilliseconds在这里的作用与在WaitForSingleObject（）中的作用是完全一致的。如果等待超时，函数将返回WAIT_TIMEOUT。如果返回WAIT_OBJECT_0到WAIT_OBJECT_0+nCount-1中的某个值，则说明所有指定对象的状态均为已通知状态（当fWaitAll为TRUE时）或是用以减去WAIT_OBJECT_0而得到发生通知的对象的索引（当fWaitAll为FALSE时）。如果返回值在WAIT_ABANDONED_0与WAIT_ABANDONED_0+nCount-1之间，则表示所有指定对象的状态均为已通知，且其中至少有一个对象是被丢弃的互斥对象（当fWaitAll为TRUE时），或是用以减去WAIT_OBJECT_0表示一个等待正常结束的互斥对象的索引（当fWaitAll为FALSE时）。 下面给出的代码主要展示了对WaitForMultipleObjects（）函数的使用。通过对两个事件内核对象的等待来控制线程任务的执行与中途退出：</font><br /></p>
<div class="cnblogs_code" onclick="cnblogs_code_show('0d8bbe75-74ba-439a-825a-134f2abb240e')"><img id="code_img_closed_0d8bbe75-74ba-439a-825a-134f2abb240e" class="code_img_closed" alt="" src="http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif" /><img style="display: none" id="code_img_opened_0d8bbe75-74ba-439a-825a-134f2abb240e" class="code_img_opened" onclick="cnblogs_code_hide('0d8bbe75-74ba-439a-825a-134f2abb240e',event)" src="http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif"><span class="cnblogs_code_collapse">代码</span> 
<div id="cnblogs_code_open_0d8bbe75-74ba-439a-825a-134f2abb240e" class="cnblogs_code_hide">
<div><!--<br/ /><br/ />Code highlighting produced by Actipro CodeHighlighter (freeware)<br/ />http://www.CodeHighlighter.com/<br/ /><br/ />--><span style="color: #000000">HANDLE&nbsp;hEvents[</span><span style="color: #800080">2</span><span style="color: #000000">];&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 　　　　　　　　　　　　　　　　　　　　　　　　　　</span><span style="color: #008000">//</span><span style="color: #008000">&nbsp;存放事件句柄的数组</span><span style="color: #008000"><br /></span><span style="color: #000000"><br />UINT&nbsp;ThreadProc14(LPVOID&nbsp;pParam)<br />{&nbsp;<br />　DWORD&nbsp;dwRet1&nbsp;</span><span style="color: #000000">=</span><span style="color: #000000">&nbsp;WaitForMultipleObjects(</span><span style="color: #800080">2</span><span style="color: #000000">,&nbsp;hEvents,&nbsp;FALSE,&nbsp;INFINITE);　</span><span style="color: #008000">//</span><span style="color: #008000">&nbsp;等待开启事件</span><span style="color: #008000"><br /></span><span style="color: #000000">　<br />　</span><span style="color: #0000ff">if</span><span style="color: #000000">&nbsp;(dwRet1&nbsp;</span><span style="color: #000000">==</span><span style="color: #000000">&nbsp;WAIT_OBJECT_0)　　　　　　　　　　　　　　　　　　　　　　　</span><span style="color: #008000">//</span><span style="color: #008000">&nbsp;如果开启事件到达则线程开始执行任务</span><span style="color: #008000"><br /></span><span style="color: #000000">　{<br />　　AfxMessageBox(</span><span style="color: #800000">"</span><span style="color: #800000">线程开始工作!</span><span style="color: #800000">"</span><span style="color: #000000">);<br />　　</span><span style="color: #0000ff">while</span><span style="color: #000000">&nbsp;(</span><span style="color: #0000ff">true</span><span style="color: #000000">)<br />　　{<br />　　　</span><span style="color: #0000ff">for</span><span style="color: #000000">&nbsp;(</span><span style="color: #0000ff">int</span><span style="color: #000000">&nbsp;i&nbsp;</span><span style="color: #000000">=</span><span style="color: #000000">&nbsp;</span><span style="color: #800080">0</span><span style="color: #000000">;&nbsp;i&nbsp;</span><span style="color: #000000">&lt;</span><span style="color: #000000">&nbsp;</span><span style="color: #800080">10000</span><span style="color: #000000">;&nbsp;i</span><span style="color: #000000">++</span><span style="color: #000000">);<br />　　　<br />　　　DWORD&nbsp;dwRet2&nbsp;</span><span style="color: #000000">=</span><span style="color: #000000">&nbsp;WaitForMultipleObjects(</span><span style="color: #800080">2</span><span style="color: #000000">,&nbsp;hEvents,&nbsp;FALSE,&nbsp;</span><span style="color: #800080">0</span><span style="color: #000000">);　　　</span><span style="color: #008000">//</span><span style="color: #008000">&nbsp;在任务处理过程中等待结束事件&nbsp;</span><span style="color: #008000"><br /></span><span style="color: #000000">　　　<br />　　　</span><span style="color: #0000ff">if</span><span style="color: #000000">&nbsp;(dwRet2&nbsp;</span><span style="color: #000000">==</span><span style="color: #000000">&nbsp;WAIT_OBJECT_0&nbsp;</span><span style="color: #000000">+</span><span style="color: #000000">&nbsp;</span><span style="color: #800080">1</span><span style="color: #000000">)　　　　　　　　　　　　　　　　　　　</span><span style="color: #008000">//</span><span style="color: #008000">&nbsp;如果结束事件置位则立即终止任务的执行</span><span style="color: #008000"><br /></span><span style="color: #000000">　　　　</span><span style="color: #0000ff">break</span><span style="color: #000000">;<br />　　}<br />　}<br />　AfxMessageBox(</span><span style="color: #800000">"</span><span style="color: #800000">线程退出!</span><span style="color: #800000">"</span><span style="color: #000000">);<br />　</span><span style="color: #0000ff">return</span><span style="color: #000000">&nbsp;</span><span style="color: #800080">0</span><span style="color: #000000">;<br />}<br />&#8230;&#8230;<br /></span><span style="color: #0000ff">void</span><span style="color: #000000">&nbsp;CSample08View::OnStartEvent()&nbsp;<br />{<br />　&nbsp;&nbsp;</span><span style="color: #0000ff">for</span><span style="color: #000000">&nbsp;(</span><span style="color: #0000ff">int</span><span style="color: #000000">&nbsp;i&nbsp;</span><span style="color: #000000">=</span><span style="color: #000000">&nbsp;</span><span style="color: #800080">0</span><span style="color: #000000">;&nbsp;i&nbsp;</span><span style="color: #000000">&lt;</span><span style="color: #000000">&nbsp;</span><span style="color: #800080">2</span><span style="color: #000000">;&nbsp;i</span><span style="color: #000000">++</span><span style="color: #000000">)　　　　　　　　　　　　　　　　　　　　　　</span><span style="color: #008000">//</span><span style="color: #008000">&nbsp;创建线程</span><span style="color: #008000"><br /></span><span style="color: #000000">　　hEvents[i]&nbsp;</span><span style="color: #000000">=</span><span style="color: #000000">&nbsp;CreateEvent(NULL,&nbsp;FALSE,&nbsp;FALSE,&nbsp;NULL);<br />　　AfxBeginThread(ThreadProc14,&nbsp;NULL);　　　　　　　　　　　　　　　　　 </span><span style="color: #008000">//</span><span style="color: #008000">&nbsp;开启线程</span><span style="color: #008000"><br /></span><span style="color: #000000">　　SetEvent(hEvents[</span><span style="color: #800080">0</span><span style="color: #000000">]);　　　　　　　　　　　　　　　　　　　　　　　　　 </span><span style="color: #008000">//</span><span style="color: #008000">&nbsp;设置事件0(开启事件)</span><span style="color: #008000"><br /></span><span style="color: #000000"><br />}<br /></span><span style="color: #0000ff">void</span><span style="color: #000000">&nbsp;CSample08View::OnEndevent()&nbsp;<br />{<br />　　SetEvent(hEvents[</span><span style="color: #800080">1</span><span style="color: #000000">]);　　　　　　　　　　　　　　　　　　　　　　　　　　</span><span style="color: #008000">//</span><span style="color: #008000">&nbsp;设置事件1(结束事件)</span><span style="color: #008000"><br /></span><span style="color: #000000"><br />}</span></div></div></div>
<p><font color="#232323" size="2">　　MFC为事件相关处理也提供了一个CEvent类，共包含有除构造函数外的4个成员函数PulseEvent（）、ResetEvent（）、SetEvent（）和UnLock（）。在功能上分别相当与Win32 API的PulseEvent（）、ResetEvent（）、SetEvent（）和CloseHandle（）等函数。而构造函数则履行了原CreateEvent（）函数创建事件对象的职责，其函数原型为：<br /><span style="font-size: 10pt">　　CEvent(BOOL bInitiallyOwn = FALSE, BOOL bManualReset = FALSE, LPCTSTR lpszName = NULL, LPSECURITY_ATTRIBUTES lpsaAttribute = NULL );</span></font></p>
<p><font color="#232323" size="2"><span style="font-size: 10pt"></span>&nbsp;</p></font>
<p><font color="#232323" size="2"><strong><font color="#232323" size="2">　　3.信号量内核对象</font></strong></font></p>
<p><font color="#232323" size="2"><font color="#232323" size="2">　　信号量（Semaphore）内核对象对线程的同步方式与前面几种方法不同，它允许多个线程在同一时刻访问同一资源，但是需要限制在同一时刻访问此资源的最大线程数目。在用CreateSemaphore（）创建信号量时即要同时指出允许的最大资源计数和当前可用资源计数。一般是将当前可用资源计数设置为最大资源计数，每增加一个线程对共享资源的访问，当前可用资源计数就会减1，只要当前可用资源计数是大于0的，就可以发出信号量信号。但是当前可用计数减小到0时则说明当前占用资源的线程数已经达到了所允许的最大数目，不能在允许其他线程的进入，此时的信号量信号将无法发出。线程在处理完共享资源后，应在离开的同时通过ReleaseSemaphore（）函数将当前可用资源计数加1。在任何时候当前可用资源计数决不可能大于最大资源计数。</font><br /><font color="#232323" size="2">　　使用信号量内核对象进行线程同步主要会用到CreateSemaphore（）、OpenSemaphore（）、ReleaseSemaphore（）、WaitForSingleObject（）和WaitForMultipleObjects（）等函数。其中，CreateSemaphore（）用来创建一个信号量内核对象，其函数原型为：</font></font><font color="#232323" size="2"></p>
<div class="cnblogs_code">
<div><!--<br/ /><br/ />Code highlighting produced by Actipro CodeHighlighter (freeware)<br/ />http://www.CodeHighlighter.com/<br/ /><br/ />--><span style="color: #000000">HANDLE&nbsp;CreateSemaphore(<br />　LPSECURITY_ATTRIBUTES&nbsp;lpSemaphoreAttributes,&nbsp;</span><span style="color: #008000">//</span><span style="color: #008000">&nbsp;安全属性指针</span><span style="color: #008000"><br /></span><span style="color: #000000">　LONG&nbsp;lInitialCount,&nbsp;　　　　　　　　　　　　　　</span><span style="color: #008000">//</span><span style="color: #008000">&nbsp;初始计数</span><span style="color: #008000"><br /></span><span style="color: #000000">　LONG&nbsp;lMaximumCount,&nbsp;　　　　　　　　　　　　　　</span><span style="color: #008000">//</span><span style="color: #008000">&nbsp;最大计数</span><span style="color: #008000"><br /></span><span style="color: #000000">　LPCTSTR&nbsp;lpName&nbsp;　　　　　　　　　　　　　　　　　</span><span style="color: #008000">//</span><span style="color: #008000">&nbsp;对象名指针</span><span style="color: #008000"><br /></span><span style="color: #000000">);&nbsp;&nbsp;<br /></span></div></div>
<p><font color="#232323" size="2">　　参数lMaximumCount是一个有符号32位值，定义了允许的最大资源计数，最大取值不能超过4294967295。lpName参数可以为创建的信号量定义一个名字，由于其创建的是一个内核对象，因此在其他进程中可以通过该名字而得到此信号量。OpenSemaphore（）函数即可用来根据信号量名打开在其他进程中创建的信号量，函数原型如下：</p>
<div class="cnblogs_code">
<div><!--<br/ /><br/ />Code highlighting produced by Actipro CodeHighlighter (freeware)<br/ />http://www.CodeHighlighter.com/<br/ /><br/ />--><span style="color: #000000">HANDLE&nbsp;OpenSemaphore(<br />　DWORD&nbsp;dwDesiredAccess,&nbsp;　　</span><span style="color: #008000">//</span><span style="color: #008000">&nbsp;访问标志</span><span style="color: #008000"><br /></span><span style="color: #000000">　BOOL&nbsp;bInheritHandle,&nbsp;　　　</span><span style="color: #008000">//</span><span style="color: #008000">&nbsp;继承标志</span><span style="color: #008000"><br /></span><span style="color: #000000">　LPCTSTR&nbsp;lpName&nbsp;　　　　　　 </span><span style="color: #008000">//</span><span style="color: #008000">&nbsp;信号量名</span><span style="color: #008000"><br /></span><span style="color: #000000">);&nbsp;<br /></span></div></div>
<p></font><font color="#232323" size="2">　　在线程离开对共享资源的处理时，必须通过ReleaseSemaphore（）来增加当前可用资源计数。否则将会出现当前正在处理共享资源的实际线程数并没有达到要限制的数值，而其他线程却因为当前可用资源计数为0而仍无法进入的情况。ReleaseSemaphore（）的函数原型为：</font></p></font></span></font>
<div class="cnblogs_code">
<div><!--<br/ /><br/ />Code highlighting produced by Actipro CodeHighlighter (freeware)<br/ />http://www.CodeHighlighter.com/<br/ /><br/ />--><span style="color: #000000">BOOL&nbsp;ReleaseSemaphore(<br />　HANDLE&nbsp;hSemaphore,&nbsp;</span><span style="color: #008000">　　 //</span><span style="color: #008000">&nbsp;信号量句柄</span><span style="color: #008000"><br /></span><span style="color: #000000">　LONG&nbsp;lReleaseCount,&nbsp;</span><span style="color: #008000">　　//</span><span style="color: #008000">&nbsp;计数递增数量</span><span style="color: #008000"><br /></span><span style="color: #000000">　LPLONG&nbsp;lpPreviousCount&nbsp; </span><span style="color: #008000">//</span><span style="color: #008000">&nbsp;先前计数</span><span style="color: #008000"><br /></span><span style="color: #000000">);</span></div></div>
<p><font color="#232323" size="2">　　该函数将lReleaseCount中的值添加给信号量的当前资源计数，一般将lReleaseCount设置为1，如果需要也可以设置其他的值。WaitForSingleObject（）和WaitForMultipleObjects（）主要用在试图进入共享资源的线程函数入口处，主要用来判断信号量的当前可用资源计数是否允许本线程的进入。只有在当前可用资源计数值大于0时，被监视的信号量内核对象才会得到通知。<br />　　信号量的使用特点使其更适用于对Socket（套接字）程序中线程的同步。例如，网络上的HTTP服务器要对同一时间内访问同一页面的用户数加以限制，这时可以为没一个用户对服务器的页面请求设置一个线程，而页面则是待保护的共享资源，通过使用信号量对线程的同步作用可以确保在任一时刻无论有多少用户对某一页面进行访问，只有不大于设定的最大用户数目的线程能够进行访问，而其他的访问企图则被挂起，只有在有用户退出对此页面的访问后才有可能进入。下面给出的示例代码即展示了类似的处理过程：</font><br /></p>
<div class="cnblogs_code" onclick="cnblogs_code_show('3e60ba68-40a7-4da1-bde2-fe87bfb16183')"><img id="code_img_closed_3e60ba68-40a7-4da1-bde2-fe87bfb16183" class="code_img_closed" alt="" src="http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif" /><img style="display: none" id="code_img_opened_3e60ba68-40a7-4da1-bde2-fe87bfb16183" class="code_img_opened" onclick="cnblogs_code_hide('3e60ba68-40a7-4da1-bde2-fe87bfb16183',event)" src="http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif"><span class="cnblogs_code_collapse">代码</span> 
<div id="cnblogs_code_open_3e60ba68-40a7-4da1-bde2-fe87bfb16183" class="cnblogs_code_hide">
<div><!--<br/ /><br/ />Code highlighting produced by Actipro CodeHighlighter (freeware)<br/ />http://www.CodeHighlighter.com/<br/ /><br/ />--><span style="color: #000000">HANDLE&nbsp;hSemaphore;　　　　　　　　　　　　　　　　 </span><span style="color: #008000">//</span><span style="color: #008000">&nbsp;信号量对象句柄</span><span style="color: #008000"><br /></span><span style="color: #000000"><br />UINT&nbsp;ThreadProc15(LPVOID&nbsp;pParam)<br />{&nbsp;<br />　WaitForSingleObject(hSemaphore,&nbsp;INFINITE);　　</span><span style="color: #008000">//</span><span style="color: #008000">&nbsp;试图进入信号量关口</span><span style="color: #008000"><br /></span><span style="color: #000000">　<br />　AfxMessageBox(</span><span style="color: #800000">"</span><span style="color: #800000">线程一正在执行!</span><span style="color: #800000">"</span><span style="color: #000000">);　　　　　　　　</span><span style="color: #008000">//</span><span style="color: #008000">&nbsp;线程任务处理</span><span style="color: #008000"><br /></span><span style="color: #000000">　<br />　ReleaseSemaphore(hSemaphore,&nbsp;</span><span style="color: #800080">1</span><span style="color: #000000">,&nbsp;NULL);　　　　</span><span style="color: #008000">//</span><span style="color: #008000">&nbsp;释放信号量计数</span><span style="color: #008000"><br /></span><span style="color: #000000">　</span><span style="color: #0000ff">return</span><span style="color: #000000">&nbsp;</span><span style="color: #800080">0</span><span style="color: #000000">;<br />}<br />UINT&nbsp;ThreadProc16(LPVOID&nbsp;pParam)<br />{&nbsp;<br /><br />　WaitForSingleObject(hSemaphore,&nbsp;INFINITE);<br /><br />　AfxMessageBox(</span><span style="color: #800000">"</span><span style="color: #800000">线程二正在执行!</span><span style="color: #800000">"</span><span style="color: #000000">);<br /><br />　ReleaseSemaphore(hSemaphore,&nbsp;</span><span style="color: #800080">1</span><span style="color: #000000">,&nbsp;NULL);<br />　</span><span style="color: #0000ff">return</span><span style="color: #000000">&nbsp;</span><span style="color: #800080">0</span><span style="color: #000000">;<br />}<br />UINT&nbsp;ThreadProc17(LPVOID&nbsp;pParam)<br />{&nbsp;<br /><br />　WaitForSingleObject(hSemaphore,&nbsp;INFINITE);<br /><br />　AfxMessageBox(</span><span style="color: #800000">"</span><span style="color: #800000">线程三正在执行!</span><span style="color: #800000">"</span><span style="color: #000000">);<br /><br />　ReleaseSemaphore(hSemaphore,&nbsp;</span><span style="color: #800080">1</span><span style="color: #000000">,&nbsp;NULL);<br />　</span><span style="color: #0000ff">return</span><span style="color: #000000">&nbsp;</span><span style="color: #800080">0</span><span style="color: #000000">;<br />}<br />&#8230;&#8230;<br /></span><span style="color: #0000ff">void</span><span style="color: #000000">&nbsp;CSample08View::OnSemaphore()&nbsp;<br />{<br />　hSemaphore&nbsp;</span><span style="color: #000000">=</span><span style="color: #000000">&nbsp;CreateSemaphore(NULL,&nbsp;</span><span style="color: #800080">2</span><span style="color: #000000">,&nbsp;</span><span style="color: #800080">2</span><span style="color: #000000">,&nbsp;NULL);　　</span><span style="color: #008000">//</span><span style="color: #008000">&nbsp;创建信号量对象</span><span style="color: #008000"><br /></span><span style="color: #000000"><br />　AfxBeginThread(ThreadProc15,&nbsp;NULL);　　　　　　　　　</span><span style="color: #008000">//</span><span style="color: #008000">&nbsp;开启线程</span><span style="color: #008000"><br /></span><span style="color: #000000">　AfxBeginThread(ThreadProc16,&nbsp;NULL);<br />　AfxBeginThread(ThreadProc17,&nbsp;NULL);<br />}</span></div></div></div>
<p><font color="#232323" size="2">　　在MFC中，通过CSemaphore类对信号量作了表述。该类只具有一个构造函数，可以构造一个信号量对象，并对初始资源计数、最大资源计数、对象名和安全属性等进行初始化，其原型如下：</font></p>
<p><font color="#232323" size="2"></font>&nbsp;<span style="font-size: 10pt">　　CSemaphore( LONG lInitialCount = 1, LONG lMaxCount = 1, LPCTSTR pstrName = NULL, LPSECURITY_ATTRIBUTES lpsaAttributes = NULL );</span></p>
<p><span style="font-size: 10pt"><font color="#232323" size="2">　　在构造了CSemaphore类对象后，任何一个访问受保护共享资源的线程都必须通过CSemaphore从父类CSyncObject类继承得到的Lock（）和UnLock（）成员函数来访问或释放CSemaphore对象。与前面介绍的几种通过MFC类保持线程同步的方法类似，通过CSemaphore类也可以将前面的线程同步代码进行改写，这两种使用信号量的线程同步方法无论是在实现原理上还是从实现结果上都是完全一致的。下面给出经MFC改写后的信号量线程同步代码：</font><br /></p>
<div class="cnblogs_code" onclick="cnblogs_code_show('86884ad4-aa48-4705-8d3b-0b31b04a307b')"><img id="code_img_closed_86884ad4-aa48-4705-8d3b-0b31b04a307b" class="code_img_closed" alt="" src="http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif" /><img style="display: none" id="code_img_opened_86884ad4-aa48-4705-8d3b-0b31b04a307b" class="code_img_opened" onclick="cnblogs_code_hide('86884ad4-aa48-4705-8d3b-0b31b04a307b',event)" src="http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif"><span class="cnblogs_code_collapse">代码</span> 
<div id="cnblogs_code_open_86884ad4-aa48-4705-8d3b-0b31b04a307b" class="cnblogs_code_hide">
<div><!--<br/ /><br/ />Code highlighting produced by Actipro CodeHighlighter (freeware)<br/ />http://www.CodeHighlighter.com/<br/ /><br/ />--><span style="color: #008000">//</span><span style="color: #008000">&nbsp;MFC信号量类对象</span><span style="color: #008000"><br /></span><span style="color: #000000">CSemaphore&nbsp;g_clsSemaphore(</span><span style="color: #800080">2</span><span style="color: #000000">,&nbsp;</span><span style="color: #800080">2</span><span style="color: #000000">);<br />UINT&nbsp;ThreadProc24(LPVOID&nbsp;pParam)<br />{&nbsp;<br />　</span><span style="color: #008000">//</span><span style="color: #008000">&nbsp;试图进入信号量关口</span><span style="color: #008000"><br /></span><span style="color: #000000">　g_clsSemaphore.Lock();<br />　</span><span style="color: #008000">//</span><span style="color: #008000">&nbsp;线程任务处理</span><span style="color: #008000"><br /></span><span style="color: #000000">　AfxMessageBox(</span><span style="color: #800000">"</span><span style="color: #800000">线程一正在执行!</span><span style="color: #800000">"</span><span style="color: #000000">);<br />　</span><span style="color: #008000">//</span><span style="color: #008000">&nbsp;释放信号量计数</span><span style="color: #008000"><br /></span><span style="color: #000000">　g_clsSemaphore.Unlock();<br />　</span><span style="color: #0000ff">return</span><span style="color: #000000">&nbsp;</span><span style="color: #800080">0</span><span style="color: #000000">;<br />}<br />UINT&nbsp;ThreadProc25(LPVOID&nbsp;pParam)<br />{<br />　</span><span style="color: #008000">//</span><span style="color: #008000">&nbsp;试图进入信号量关口</span><span style="color: #008000"><br /></span><span style="color: #000000">　g_clsSemaphore.Lock();<br />　</span><span style="color: #008000">//</span><span style="color: #008000">&nbsp;线程任务处理</span><span style="color: #008000"><br /></span><span style="color: #000000">　AfxMessageBox(</span><span style="color: #800000">"</span><span style="color: #800000">线程二正在执行!</span><span style="color: #800000">"</span><span style="color: #000000">);<br />　</span><span style="color: #008000">//</span><span style="color: #008000">&nbsp;释放信号量计数</span><span style="color: #008000"><br /></span><span style="color: #000000">　g_clsSemaphore.Unlock();<br />　</span><span style="color: #0000ff">return</span><span style="color: #000000">&nbsp;</span><span style="color: #800080">0</span><span style="color: #000000">;<br />}<br />UINT&nbsp;ThreadProc26(LPVOID&nbsp;pParam)<br />{<br />　</span><span style="color: #008000">//</span><span style="color: #008000">&nbsp;试图进入信号量关口</span><span style="color: #008000"><br /></span><span style="color: #000000">　g_clsSemaphore.Lock();<br />　</span><span style="color: #008000">//</span><span style="color: #008000">&nbsp;线程任务处理</span><span style="color: #008000"><br /></span><span style="color: #000000">　AfxMessageBox(</span><span style="color: #800000">"</span><span style="color: #800000">线程三正在执行!</span><span style="color: #800000">"</span><span style="color: #000000">);<br />　</span><span style="color: #008000">//</span><span style="color: #008000">&nbsp;释放信号量计数</span><span style="color: #008000"><br /></span><span style="color: #000000">　g_clsSemaphore.Unlock();<br />　</span><span style="color: #0000ff">return</span><span style="color: #000000">&nbsp;</span><span style="color: #800080">0</span><span style="color: #000000">;<br />}<br />&#8230;&#8230;<br /></span><span style="color: #0000ff">void</span><span style="color: #000000">&nbsp;CSample08View::OnSemaphoreMfc()&nbsp;<br />{<br />　</span><span style="color: #008000">//</span><span style="color: #008000">&nbsp;开启线程</span><span style="color: #008000"><br /></span><span style="color: #000000">　AfxBeginThread(ThreadProc24,&nbsp;NULL);<br />　AfxBeginThread(ThreadProc25,&nbsp;NULL);<br />　AfxBeginThread(ThreadProc26,&nbsp;NULL);<br />}</span></div></div></div>
<p>&nbsp;</p><font size="2"><font color="#232323">&nbsp;&nbsp;&nbsp;&nbsp; 4.<strong>互斥内核对象</strong></font></font> 
<p><font color="#232323" size="2">&nbsp;&nbsp;&nbsp;&nbsp; <span style="font-size: 10pt">互斥（Mutex）是一种用途非常广泛的内核对象。能够保证多个线程对同一共享资源的互斥访问。同临界区有些类似，只有拥有互斥对象的线程才具有访问资源的权限，由于互斥对象只有一个，因此就决定了任何情况下此共享资源都不会同时被多个线程所访问。当前占据资源的线程在任务处理完后应将拥有的互斥对象交出，以便其他线程在获得后得以访问资源。与其他几种内核对象不同，互斥对象在操作系统中拥有特殊代码，并由操作系统来管理，操作系统甚至还允许其进行一些其他内核对象所不能进行的非常规操作。</span></font></p><font color="#232323" size="2">&nbsp;&nbsp;&nbsp;&nbsp; 以互斥内核对象来保持线程同步可能用到的函数主要有CreateMutex（）、OpenMutex（）、ReleaseMutex（）、WaitForSingleObject（）和WaitForMultipleObjects（）等。在使用互斥对象前，首先要通过CreateMutex（）或OpenMutex（）创建或打开一个互斥对象。CreateMutex（）函数原型为：</font><br />
<p><font color="#232323" size="2"><span style="font-size: 10pt"><span style="font-size: 10pt">&nbsp;&nbsp;&nbsp;&nbsp; HANDLE CreateMutex(<br />　&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; LPSECURITY_ATTRIBUTES lpMutexAttributes, // 安全属性指针<br />　&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; BOOL bInitialOwner, // 初始拥有者<br />　&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; LPCTSTR lpName // 互斥对象名<br />&nbsp;&nbsp;&nbsp;&nbsp; );</span></span></font></p>
<p><font color="#232323" size="2"><span style="font-size: 10pt"><span style="font-size: 10pt">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;参数bInitialOwner主要用来控制互斥对象的初始状态。一般多将其设置为FALSE，以表明互斥对象在创建时并没有为任何线程所占有。如果在创建互斥对象时指定了对象名，那么可以在本进程其他地方或是在其他进程通过OpenMutex（）函数得到此互斥对象的句柄。OpenMutex（）函数原型为：</span></span></font></p>
<p><font color="#232323" size="2"><span style="font-size: 10pt"><span style="font-size: 10pt"><span style="font-size: 10pt">&nbsp;&nbsp;&nbsp; HANDLE OpenMutex(<br />　&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DWORD dwDesiredAccess, // 访问标志<br />　&nbsp;&nbsp;&nbsp;&nbsp; BOOL bInheritHandle, // 继承标志<br />　&nbsp;&nbsp;&nbsp;&nbsp; LPCTSTR lpName // 互斥对象名<br />&nbsp;&nbsp;&nbsp; ); </span></span></span></font></p>
<p><font color="#232323" size="2"><span style="font-size: 10pt"><span style="font-size: 10pt"><span style="font-size: 10pt">&nbsp;&nbsp;&nbsp;&nbsp; 当目前对资源具有访问权的线程不再需要访问此资源而要离开时，必须通过ReleaseMutex（）函数来释放其拥有的互斥对象，其函数原型为：</span></span></span></font></p>
<p><font color="#232323" size="2"><span style="font-size: 10pt"><span style="font-size: 10pt"><span style="font-size: 10pt"><span style="font-size: 10pt">&nbsp;&nbsp;&nbsp;&nbsp;BOOL ReleaseMutex(HANDLE hMutex);</span></span></span></span></font></p>
<p><font color="#232323" size="2"><span style="font-size: 10pt"><span style="font-size: 10pt"><span style="font-size: 10pt"><span style="font-size: 10pt">&nbsp;&nbsp;&nbsp; 其唯一的参数hMutex为待释放的互斥对象句柄。至于WaitForSingleObject（）和WaitForMultipleObjects（）等待函数在互斥对象保持线程同步中所起的作用与在其他内核对象中的作用是基本一致的，也是等待互斥内核对象的通知。但是这里需要特别指出的是：在互斥对象通知引起调用等待函数返回时，等待函数的返回值不再是通常的WAIT_OBJECT_0（对于WaitForSingleObject（）函数）或是在WAIT_OBJECT_0到WAIT_OBJECT_0+nCount-1之间的一个值（对于WaitForMultipleObjects（）函数），而是将返回一个WAIT_ABANDONED_0（对于WaitForSingleObject（）函数）或是在WAIT_ABANDONED_0到WAIT_ABANDONED_0+nCount-1之间的一个值（对于WaitForMultipleObjects（）函数）。以此来表明线程正在等待的互斥对象由另外一个线程所拥有，而此线程却在使用完共享资源前就已经终止。除此之外，使用互斥对象的方法在等待线程的可调度性上同使用其他几种内核对象的方法也有所不同，其他内核对象在没有得到通知时，受调用等待函数的作用，线程将会挂起，同时失去可调度性，而使用互斥的方法却可以在等待的同时仍具有可调度性，这也正是互斥对象所能完成的非常规操作之一。<br />　　在编写程序时，互斥对象多用在对那些为多个线程所访问的内存块的保护上，可以确保任何线程在处理此内存块时都对其拥有可靠的独占访问权。下面给出的示例代码即通过互斥内核对象hMutex对共享内存快g_cArray[]进行线程的独占访问保护。下面给出实现代码清单：</span></span></span></span></font></p>
<p><font color="#232323" size="2"><span style="font-size: 10pt"><span style="font-size: 10pt"><span style="font-size: 10pt"><span style="font-size: 10pt"></p>
<div class="cnblogs_code" onclick="cnblogs_code_show('bbed526c-36e6-41b9-ae77-033b8f713086')"><img id="code_img_closed_bbed526c-36e6-41b9-ae77-033b8f713086" class="code_img_closed" alt="" src="http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif" /><img style="display: none" id="code_img_opened_bbed526c-36e6-41b9-ae77-033b8f713086" class="code_img_opened" onclick="cnblogs_code_hide('bbed526c-36e6-41b9-ae77-033b8f713086',event)" src="http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif"><span class="cnblogs_code_collapse">代码</span> 
<div id="cnblogs_code_open_bbed526c-36e6-41b9-ae77-033b8f713086" class="cnblogs_code_hide">
<div><!--<br/ /><br/ />Code highlighting produced by Actipro CodeHighlighter (freeware)<br/ />http://www.CodeHighlighter.com/<br/ /><br/ />--><span style="color: #008000">//</span><span style="color: #008000">&nbsp;互斥对象</span><span style="color: #008000"><br /></span><span style="color: #000000">HANDLE&nbsp;hMutex&nbsp;</span><span style="color: #000000">=</span><span style="color: #000000">&nbsp;NULL;<br /></span><span style="color: #0000ff">char</span><span style="color: #000000">&nbsp;g_cArray[</span><span style="color: #800080">10</span><span style="color: #000000">];<br />UINT&nbsp;ThreadProc18(LPVOID&nbsp;pParam)<br />{<br />　</span><span style="color: #008000">//</span><span style="color: #008000">&nbsp;等待互斥对象通知</span><span style="color: #008000"><br /></span><span style="color: #000000">　WaitForSingleObject(hMutex,&nbsp;INFINITE);<br />　</span><span style="color: #008000">//</span><span style="color: #008000">&nbsp;对共享资源进行写入操作</span><span style="color: #008000"><br /></span><span style="color: #000000">　</span><span style="color: #0000ff">for</span><span style="color: #000000">&nbsp;(</span><span style="color: #0000ff">int</span><span style="color: #000000">&nbsp;i&nbsp;</span><span style="color: #000000">=</span><span style="color: #000000">&nbsp;</span><span style="color: #800080">0</span><span style="color: #000000">;&nbsp;i&nbsp;</span><span style="color: #000000">&lt;</span><span style="color: #000000">&nbsp;</span><span style="color: #800080">10</span><span style="color: #000000">;&nbsp;i</span><span style="color: #000000">++</span><span style="color: #000000">)<br />　{<br />　　g_cArray[i]&nbsp;</span><span style="color: #000000">=</span><span style="color: #000000">&nbsp;</span><span style="color: #800000">'</span><span style="color: #800000">a</span><span style="color: #800000">'</span><span style="color: #000000">;<br />　　Sleep(</span><span style="color: #800080">1</span><span style="color: #000000">);<br />　}<br />　</span><span style="color: #008000">//</span><span style="color: #008000">&nbsp;释放互斥对象</span><span style="color: #008000"><br /></span><span style="color: #000000">　ReleaseMutex(hMutex);<br />　</span><span style="color: #0000ff">return</span><span style="color: #000000">&nbsp;</span><span style="color: #800080">0</span><span style="color: #000000">;<br />}<br />UINT&nbsp;ThreadProc19(LPVOID&nbsp;pParam)<br />{<br />　</span><span style="color: #008000">//</span><span style="color: #008000">&nbsp;等待互斥对象通知</span><span style="color: #008000"><br /></span><span style="color: #000000">　WaitForSingleObject(hMutex,&nbsp;INFINITE);<br />　</span><span style="color: #008000">//</span><span style="color: #008000">&nbsp;对共享资源进行写入操作</span><span style="color: #008000"><br /></span><span style="color: #000000">　</span><span style="color: #0000ff">for</span><span style="color: #000000">&nbsp;(</span><span style="color: #0000ff">int</span><span style="color: #000000">&nbsp;i&nbsp;</span><span style="color: #000000">=</span><span style="color: #000000">&nbsp;</span><span style="color: #800080">0</span><span style="color: #000000">;&nbsp;i&nbsp;</span><span style="color: #000000">&lt;</span><span style="color: #000000">&nbsp;</span><span style="color: #800080">10</span><span style="color: #000000">;&nbsp;i</span><span style="color: #000000">++</span><span style="color: #000000">)<br />　{<br />　　g_cArray[</span><span style="color: #800080">10</span><span style="color: #000000">&nbsp;</span><span style="color: #000000">-</span><span style="color: #000000">&nbsp;i&nbsp;</span><span style="color: #000000">-</span><span style="color: #000000">&nbsp;</span><span style="color: #800080">1</span><span style="color: #000000">]&nbsp;</span><span style="color: #000000">=</span><span style="color: #000000">&nbsp;</span><span style="color: #800000">'</span><span style="color: #800000">b</span><span style="color: #800000">'</span><span style="color: #000000">;<br />　　Sleep(</span><span style="color: #800080">1</span><span style="color: #000000">);<br />　}<br />　</span><span style="color: #008000">//</span><span style="color: #008000">&nbsp;释放互斥对象</span><span style="color: #008000"><br /></span><span style="color: #000000">　ReleaseMutex(hMutex);<br />　</span><span style="color: #0000ff">return</span><span style="color: #000000">&nbsp;</span><span style="color: #800080">0</span><span style="color: #000000">;<br />}<br />&#8230;&#8230;<br /></span><span style="color: #0000ff">void</span><span style="color: #000000">&nbsp;CSample08View::OnMutex()&nbsp;<br />{<br />　</span><span style="color: #008000">//</span><span style="color: #008000">&nbsp;创建互斥对象</span><span style="color: #008000"><br /></span><span style="color: #000000">　hMutex&nbsp;</span><span style="color: #000000">=</span><span style="color: #000000">&nbsp;CreateMutex(NULL,&nbsp;FALSE,&nbsp;NULL);<br />　</span><span style="color: #008000">//</span><span style="color: #008000">&nbsp;启动线程</span><span style="color: #008000"><br /></span><span style="color: #000000">　AfxBeginThread(ThreadProc18,&nbsp;NULL);<br />　AfxBeginThread(ThreadProc19,&nbsp;NULL);<br />　</span><span style="color: #008000">//</span><span style="color: #008000">&nbsp;等待计算完毕</span><span style="color: #008000"><br /></span><span style="color: #000000">　Sleep(</span><span style="color: #800080">300</span><span style="color: #000000">);<br />　</span><span style="color: #008000">//</span><span style="color: #008000">&nbsp;报告计算结果</span><span style="color: #008000"><br /></span><span style="color: #000000">　CString&nbsp;sResult&nbsp;</span><span style="color: #000000">=</span><span style="color: #000000">&nbsp;CString(g_cArray);<br />　AfxMessageBox(sResult);<br />}&nbsp;</span></div></div></div>
<p><font color="#232323" size="2">&nbsp;&nbsp;&nbsp;&nbsp; 互斥对象在MFC中通过CMutex类进行表述。使用CMutex类的方法非常简单，在构造CMutex类对象的同时可以指明待查询的互斥对象的名字，在构造函数返回后即可访问此互斥变量。CMutex类也是只含有构造函数这唯一的成员函数，当完成对互斥对象保护资源的访问后，可通过调用从父类CSyncObject继承的UnLock（）函数完成对互斥对象的释放。CMutex类构造函数原型为：</font><br /><span style="font-size: 10pt">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;CMutex( BOOL bInitiallyOwn = FALSE, LPCTSTR lpszName = NULL, LPSECURITY_ATTRIBUTES lpsaAttribute = NULL );</span></p><font color="#232323" size="2">&nbsp;&nbsp;&nbsp; 该类的适用范围和实现原理与API方式创建的互斥内核对象是完全类似的，但要简洁的多，下面给出就是对前面的示例代码经CMutex类改写后的程序实现清单：</font> 
<p><span style="font-size: 10pt"></p>
<div class="cnblogs_code" onclick="cnblogs_code_show('12e1ec39-35ac-4b47-8242-ac3a1e165c8e')"><img id="code_img_closed_12e1ec39-35ac-4b47-8242-ac3a1e165c8e" class="code_img_closed" alt="" src="http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif" /><img style="display: none" id="code_img_opened_12e1ec39-35ac-4b47-8242-ac3a1e165c8e" class="code_img_opened" onclick="cnblogs_code_hide('12e1ec39-35ac-4b47-8242-ac3a1e165c8e',event)" src="http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif"><span class="cnblogs_code_collapse">代码</span> 
<div id="cnblogs_code_open_12e1ec39-35ac-4b47-8242-ac3a1e165c8e" class="cnblogs_code_hide">
<div><!--<br/ /><br/ />Code highlighting produced by Actipro CodeHighlighter (freeware)<br/ />http://www.CodeHighlighter.com/<br/ /><br/ />--><span style="color: #000000">CMutex&nbsp;g_clsMutex(FALSE,&nbsp;NULL);&nbsp;&nbsp;&nbsp;&nbsp; </span><span style="color: #008000">//</span><span style="color: #008000">&nbsp;MFC互斥类对象</span><span style="color: #008000"><br /></span><span style="color: #000000"><br />UINT&nbsp;ThreadProc27(LPVOID&nbsp;pParam)<br />{<br />　g_clsMutex.Lock();　&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span style="color: #008000">//</span><span style="color: #008000">&nbsp;等待互斥对象通知</span><span style="color: #008000"><br /></span><span style="color: #000000"><br />　</span><span style="color: #0000ff">for</span><span style="color: #000000">&nbsp;(</span><span style="color: #0000ff">int</span><span style="color: #000000">&nbsp;i&nbsp;</span><span style="color: #000000">=</span><span style="color: #000000">&nbsp;</span><span style="color: #800080">0</span><span style="color: #000000">;&nbsp;i&nbsp;</span><span style="color: #000000">&lt;</span><span style="color: #000000">&nbsp;</span><span style="color: #800080">10</span><span style="color: #000000">;&nbsp;i</span><span style="color: #000000">++</span><span style="color: #000000">)　&nbsp;&nbsp;&nbsp;&nbsp; </span><span style="color: #008000">//</span><span style="color: #008000">&nbsp;对共享资源进行写入操作</span><span style="color: #008000"><br /></span><span style="color: #000000">　{<br />　　g_cArray[i]&nbsp;</span><span style="color: #000000">=</span><span style="color: #000000">&nbsp;</span><span style="color: #800000">'</span><span style="color: #800000">a</span><span style="color: #800000">'</span><span style="color: #000000">;<br />　　Sleep(</span><span style="color: #800080">1</span><span style="color: #000000">);<br />　}<br /><br />　g_clsMutex.Unlock();　&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span style="color: #008000">//</span><span style="color: #008000">&nbsp;释放互斥对象</span><span style="color: #008000"><br /></span><span style="color: #000000">　</span><span style="color: #0000ff">return</span><span style="color: #000000">&nbsp;</span><span style="color: #800080">0</span><span style="color: #000000">;<br />}<br />UINT&nbsp;ThreadProc28(LPVOID&nbsp;pParam)<br />{<br />　g_clsMutex.Lock();<br /><br />　</span><span style="color: #0000ff">for</span><span style="color: #000000">&nbsp;(</span><span style="color: #0000ff">int</span><span style="color: #000000">&nbsp;i&nbsp;</span><span style="color: #000000">=</span><span style="color: #000000">&nbsp;</span><span style="color: #800080">0</span><span style="color: #000000">;&nbsp;i&nbsp;</span><span style="color: #000000">&lt;</span><span style="color: #000000">&nbsp;</span><span style="color: #800080">10</span><span style="color: #000000">;&nbsp;i</span><span style="color: #000000">++</span><span style="color: #000000">)<br />　{<br />　　g_cArray[</span><span style="color: #800080">10</span><span style="color: #000000">&nbsp;</span><span style="color: #000000">-</span><span style="color: #000000">&nbsp;i&nbsp;</span><span style="color: #000000">-</span><span style="color: #000000">&nbsp;</span><span style="color: #800080">1</span><span style="color: #000000">]&nbsp;</span><span style="color: #000000">=</span><span style="color: #000000">&nbsp;</span><span style="color: #800000">'</span><span style="color: #800000">b</span><span style="color: #800000">'</span><span style="color: #000000">;<br />　　Sleep(</span><span style="color: #800080">1</span><span style="color: #000000">);<br />　}<br /><br />　g_clsMutex.Unlock();<br />　</span><span style="color: #0000ff">return</span><span style="color: #000000">&nbsp;</span><span style="color: #800080">0</span><span style="color: #000000">;<br />}<br />&#8230;&#8230;<br /></span><span style="color: #0000ff">void</span><span style="color: #000000">&nbsp;CSample08View::OnMutexMfc()&nbsp;<br />{<br />　AfxBeginThread(ThreadProc27,&nbsp;NULL);<br />　AfxBeginThread(ThreadProc28,&nbsp;NULL);<br /><br />　Sleep(</span><span style="color: #800080">300</span><span style="color: #000000">);<br /><br />　CString&nbsp;sResult&nbsp;</span><span style="color: #000000">=</span><span style="color: #000000">&nbsp;CString(g_cArray);<br />　AfxMessageBox(sResult);<br />}</span></div></div></div>
<p>&nbsp;</p>
<p></span></span></span></span></span></font></span>&nbsp;</p></div><div id="MySignature"></div>
<script type="text/javascript">
var isLogined = false;
var cb_blogId = 66274;
var cb_entryId = 1773113;
var cb_blogApp = currentBlogApp;
var cb_blogUserGuid = "c4c04bc5-d508-df11-ba8f-001cf0cd104b";
var cb_entryCreatedDate = '2010/7/7 19:45:00';
var enableGoogleAd = true;
var googletag = googletag || {};
googletag.cmd = googletag.cmd || [];
</script>
<div id="blog_post_info_block">
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
<script type="text/javascript">
    //SyntaxHighlighter.config.strings.expandSource = '<span><img src="http://static.cnblogs.com/images/expand-code.gif" alt="" class="expand-code-icon"/>View Code</span>';
    $(function () {             
        fixPostBodyFormat();
        loadAdUnderPost();
        loadBlogSignature();
        LoadPostInfoBlock(cb_blogId, cb_entryId, cb_blogApp, cb_blogUserGuid);
        GetPrevNextPost(cb_entryId, cb_blogId, cb_entryCreatedDate);        
        GetHistoryToday(cb_blogId, cb_blogApp, cb_entryCreatedDate);        
    });
</script>
	<div class = "postDesc">posted on <span id="post-date">2010-07-07 19:45</span> <a href='http://www.cnblogs.com/zqrferrari/'>赵情融</a> 阅读(3073) 评论(<span id="post-comment-count">0</span>)  <a href ="http://www.cnblogs.com/zqrferrari/admin/EditPosts.aspx?postid=1773113" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(1773113);return false;">收藏</a></div>
</div>
<img src ="http://www.cnblogs.com/zqrferrari/aggbug/1773113.html?type=1&amp;webview=1" width="1" height="1" alt=""/>

<div id="blog-comments-placeholder"></div><script type="text/javascript">var commentManager = new blogCommentManager();commentManager.loadComments();</script>
<div id="comment_form" class="commentform">
<div id="divCommentShow"></div>
<div id="comment_nav"><span id="span_refresh_tips"></span><a href="javascript:void(0);" id="lnk_RefreshComments" onclick="return RefreshCommentList();">刷新评论</a><a href="#" onclick="return RefreshPage();">刷新页面</a><a href="#top">返回顶部</a></div>
<div id="comment_form_container"></div>

<script type="text/javascript">
    if (typeof commentManager === 'undefined') {
        commentManager = new blogCommentManager();
    }
    commentManager.loadCommentForm();   
</script>

<div class="ad_text_commentbox"><a href="http://q.cnblogs.com/" target="_blank">程序员问答社区，解决您的技术难题</a></div>
<div id="site_nav_under"><a href="http://www.cnblogs.com/" target="_blank" title="程序员的网上家园">博客园首页</a><a href="http://q.cnblogs.com/" target="_blank" title="程序员问答社区">博问</a><a href="http://news.cnblogs.com/" target="_blank" title="IT新闻">新闻</a><a href="http://home.cnblogs.com/ing/" target="_blank">闪存</a><a href="http://job.cnblogs.com/" target="_blank">程序员招聘</a><a href="http://kb.cnblogs.com/" target="_blank">知识库</a></div>
<div id="ad_under_post_holder"></div>
<div id="HistoryToday" class="c_ad_block"></div>
</div>





</div>

<!--done-->
<div class="footer">
	
	Copyright &copy;2012 赵情融 Powered By<a href="/">博客园</a> 模板提供：<a href="http://blog.hjenglish.com">沪江博客</a>
</div>
<script type="text/javascript" src="http://common.cnblogs.com/script/google-analytics.js"></script>
</body>
</html>
